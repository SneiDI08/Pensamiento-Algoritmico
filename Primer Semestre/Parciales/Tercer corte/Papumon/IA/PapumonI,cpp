#include <SFML/Graphics.hpp>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm> // Para std::min y std::max

// Ruta base para los assets (¡Asegúrate de que esta ruta sea correcta en tu sistema!)
const std::string ASSETS_BASE_PATH = "C:/Users/sneid/OneDrive/Escritorio/Pokemon Def/main/main/assets/";

// =====================================================================
// ENUMS Y CLASES
// =====================================================================

// Enum para los estados del juego
enum GameState {
    MAIN_MENU,
    SELECTION_PLAYER1,
    SELECTION_PLAYER2,
    BATTLE,
    GAME_OVER
};

// Enum para el turno de los jugadores
enum Turn {
    PLAYER1_TURN,
    PLAYER2_TURN
};

// Clase ataque
class ataque {
public:
    std::string nombre;
    int poder;
    int uso; // This "uso" could become "costo_aguante"
    int costo_aguante; // NEW: Stamina cost for the attack

    ataque(std::string nombre_ataque, int poder_ataque, int uso_ataque, int costo_aguante_ataque); // Modified constructor
};

// Clase papumon
class papumon {
public:
    std::string nombre;
    std::string tipo;
    int vida;
    int defensa;
    int aguante; // Current stamina
    int aguante_max; // NEW: Maximum stamina for displaying bars/etc.
    std::vector<ataque> ataques;

    sf::Texture textura;
    sf::Sprite sprite;

    papumon(std::string nombre, std::string tipo, int vida, int defensa, int aguante, std::vector<ataque> ataques);

    void cargarSprite();
    void recibirDanio(int danio);
    // NEW: Method to consume stamina
    bool consumirAguante(int cantidad);
    // NEW: Method to regenerate stamina
    void regenerarAguante(int cantidad);
};

// =====================================================================
// DECLARACIONES DE FUNCIONES AUXILIARES (Globales)
// =====================================================================

sf::Text createText(const std::string& content, const sf::Font& font, unsigned int size, sf::Color color = sf::Color::White);

// Funciones para crear ataques específicos
std::vector<ataque> ataques_viento();
std::vector<ataque> ataques_fuego();
std::vector<ataque> ataques_agua();
std::vector<ataque> ataques_tierra();
std::vector<ataque> ataques_normal();

// Función para obtener todos los Papumones disponibles
std::vector<papumon> papumones();

// Funciones de Manejo de Eventos
void handleMainMenuEvents(sf::RenderWindow& window, const sf::Event& event, GameState& currentState);
void handleSelectionEvents(sf::RenderWindow& window, const sf::Event& event, GameState& currentState,
    std::vector<papumon>& currentPlayerSelectedPapumons, const std::string& player, const sf::Font& font);
void handleBattleEvents(sf::RenderWindow& window, const sf::Event& event, GameState& currentState,
    std::vector<papumon>& equipo1, std::vector<papumon>& equipo2, Turn& currentTurn,
    int& activePapumonIdx1, int& activePapumonIdx2);

// Funciones de Dibujo
void drawMainMenu(sf::RenderWindow& window, const sf::Font& font);
void drawSelectionMenu(sf::RenderWindow& window, const sf::Font& font, const std::vector<papumon>& selectedPapumons, const std::string& player);
void drawBattleScene(sf::RenderWindow& window, const sf::Font& font, std::vector<papumon>& equipo1, std::vector<papumon>& equipo2,
    const sf::Sprite& backgroundSprite, Turn currentTurn, int activePapumonIdx1, int activePapumonIdx2);
void drawGameOver(sf::RenderWindow& window, const sf::Font& font, const std::string& winner);

// =====================================================================
// IMPLEMENTACIONES DE CLASES Y FUNCIONES AUXILIARES
// =====================================================================

// Constructor de ataque - MODIFIED
ataque::ataque(std::string nombre_ataque, int poder_ataque, int uso_ataque, int costo_aguante_ataque)
    : nombre(nombre_ataque), poder(poder_ataque), uso(uso_ataque), costo_aguante(costo_aguante_ataque) {
}

// Constructor de papumon - MODIFIED
papumon::papumon(std::string nombre, std::string tipo, int vida, int defensa, int aguante, std::vector<ataque> ataques)
    : nombre(nombre), tipo(tipo), vida(vida), defensa(defensa), aguante(aguante), aguante_max(aguante), ataques(ataques) { // aguante_max initialized
    cargarSprite();
}

// Implementación de cargarSprite
void papumon::cargarSprite() {
    // Construye la ruta completa del archivo de sprite para este Papumon específico
    // Ejemplo: ASSETS_BASE_PATH + "sprites_papumon/Ignivorax.png"
    std::string ruta = ASSETS_BASE_PATH + "sprites_papumon/" + nombre + ".png";
    if (textura.loadFromFile(ruta)) {
        sprite.setTexture(textura);
        sprite.setScale(2.0f, 2.0f); // Escala el sprite para que sea visible (doble tamaño)
    }
    else {
        std::cerr << "Error al cargar el sprite para " << nombre << " en " << ruta << std::endl;
    }
}

// Implementación de recibirDanio
void papumon::recibirDanio(int danio) {
    int danio_final = std::max(0, danio - defensa);
    vida -= danio_final;
    if (vida < 0) {
        vida = 0;
    }
    std::cout << nombre << " recibió " << danio_final << " de daño. Vida restante: " << vida << std::endl;
}

// NEW: Implementación de consumirAguante
bool papumon::consumirAguante(int cantidad) {
    if (aguante >= cantidad) {
        aguante -= cantidad;
        std::cout << nombre << " usó " << cantidad << " de aguante. Aguante restante: " << aguante << std::endl;
        return true; // Stamina successfully consumed
    }
    std::cout << nombre << " no tiene suficiente aguante para este ataque! (Necesita: " << cantidad << ", Tiene: " << aguante << ")" << std::endl;
    return false; // Not enough stamina
}

// NEW: Implementación de regenerarAguante
void papumon::regenerarAguante(int cantidad) {
    aguante = std::min(aguante_max, aguante + cantidad);
    std::cout << nombre << " regeneró " << cantidad << " de aguante. Aguante actual: " << aguante << "/" << aguante_max << std::endl;
}

// Implementación de createText
sf::Text createText(const std::string& content, const sf::Font& font, unsigned int size, sf::Color color) {
    sf::Text text;
    text.setFont(font);
    text.setString(content);
    text.setCharacterSize(size);
    text.setFillColor(color);
    return text;
}

// Funciones de ataques - MODIFIED: Added stamina cost
std::vector<ataque> ataques_viento() {
    return {
        ataque("Ráfaga Celeste", 15, 5, 5), // Power, Use, Stamina Cost
        ataque("Viento Cortante", 20, 7, 8),
        ataque("Torbellino Fantasma", 22, 10, 12),
        ataque("Neblina Tempestad", 30, 15, 20)
    };
}

std::vector<ataque> ataques_fuego() {
    return {
        ataque("Llama Ardiente", 15, 5, 5),
        ataque("Lluvia de Fuego", 20, 7, 8),
        ataque("Explosión Flamígera", 22, 10, 12),
        ataque("Tormenta de Llamas", 32, 17, 20)
    };
}

std::vector<ataque> ataques_agua() {
    return {
        ataque("Chorro de Agua", 15, 5, 5),
        ataque("Tormenta de Agua", 20, 7, 8),
        ataque("Maremoto", 22, 10, 12),
        ataque("Oleada Salvaje", 30, 15, 20)
    };
}

std::vector<ataque> ataques_tierra() {
    return {
        ataque("Terremoto", 15, 5, 5),
        ataque("Roca Afilada", 20, 7, 8),
        ataque("Desierto Enfurecido", 22, 10, 12),
        ataque("Tormenta de Tierra", 32, 17, 20)
    };
}

std::vector<ataque> ataques_normal() {
    return {
        ataque("Golpe Normal", 15, 5, 5),
        ataque("Puño Feroz", 20, 7, 8),
        ataque("Puño Desgarrador", 22, 10, 12),
        ataque("Golpe Crítico", 30, 15, 20)
    };
}

// Todos los Papumones disponibles - Papumons are initialized with their max aguante
std::vector<papumon> papumones() {
    return {
        papumon("Ignivorax", "Fuego", 100, 5, 30, ataques_fuego()),
        papumon("Aquaflare", "Agua", 100, 5, 30, ataques_agua()),
        papumon("Terraclaw", "Tierra", 100, 5, 30, ataques_tierra()),
        papumon("Ventisca", "Viento", 100, 5,30, ataques_viento()),
        papumon("Normalis", "Normal", 100, 5,30, ataques_normal()),
        papumon("Flamemur", "Fuego", 100, 5, 30, ataques_fuego()),
        papumon("Pyroscale", "Fuego", 100, 5, 30, ataques_fuego()),
        papumon("Cratonix", "Tierra", 100, 5, 30, ataques_tierra()),
        papumon("Rocazor", "Tierra", 100, 5, 30, ataques_tierra()),
        papumon("Zephyroth", "Viento", 100, 5, 30, ataques_viento()),
        papumon("Galevore", "Viento", 100, 5, 30, ataques_viento()),
        papumon("Vivantor", "Normal", 100, 5, 30, ataques_normal()),
        papumon("Andrew", "Normal", 50, 10, 15, ataques_normal())
    };
}


// =====================================================================
// IMPLEMENTACIONES DE MENÚS Y LÓGICA DEL JUEGO
// =====================================================================

// MAIN MENU (SFML) - Event Handling
void handleMainMenuEvents(sf::RenderWindow& window, const sf::Event& event, GameState& currentState) {
    if (event.type == sf::Event::MouseButtonReleased) {
        if (event.mouseButton.button == sf::Mouse::Left) {
            sf::Vector2f mousePos = window.mapPixelToCoords(sf::Vector2i(event.mouseButton.x, event.mouseButton.y));

            sf::RectangleShape startButtonArea(sf::Vector2f(200, 50));
            startButtonArea.setPosition(300, 300);

            sf::RectangleShape exitButtonArea(sf::Vector2f(200, 50));
            exitButtonArea.setPosition(300, 400);

            if (startButtonArea.getGlobalBounds().contains(mousePos)) {
                currentState = SELECTION_PLAYER1;
            }
            else if (exitButtonArea.getGlobalBounds().contains(mousePos)) {
                window.close();
            }
        }
    }
}

// MAIN MENU (SFML) - Drawing
void drawMainMenu(sf::RenderWindow& window, const sf::Font& font) {
    sf::Text title = createText("###############\n# PAPUMON :'v #\n###############", font, 48, sf::Color::Yellow);
    title.setPosition(window.getSize().x / 2 - title.getGlobalBounds().width / 2, 100);
    window.draw(title);

    sf::Text startGameText = createText("1. Iniciar Juego", font, 30);
    startGameText.setPosition(300, 300);
    window.draw(startGameText);

    sf::Text exitGameText = createText("2. Salir", font, 30);
    exitGameText.setPosition(300, 400);
    window.draw(exitGameText);

    sf::RectangleShape startButtonRect(sf::Vector2f(200, 50));
    startButtonRect.setPosition(300, 300);
    startButtonRect.setFillColor(sf::Color(0, 0, 0, 0));
    startButtonRect.setOutlineThickness(2);
    startButtonRect.setOutlineColor(sf::Color::White);
    window.draw(startButtonRect);

    sf::RectangleShape exitButtonRect(sf::Vector2f(200, 50));
    exitButtonRect.setPosition(300, 400);
    exitButtonRect.setFillColor(sf::Color(0, 0, 0, 0));
    exitButtonRect.setOutlineThickness(2);
    exitButtonRect.setOutlineColor(sf::Color::White);
    window.draw(exitButtonRect);
}

// SELECTION MENU (SFML) - Event Handling
void handleSelectionEvents(sf::RenderWindow& window, const sf::Event& event, GameState& currentState,
    std::vector<papumon>& currentPlayerSelectedPapumons, const std::string& player, const sf::Font& font) {
    if (event.type == sf::Event::MouseButtonReleased) {
        if (event.mouseButton.button == sf::Mouse::Left) {
            sf::Vector2f mousePos = window.mapPixelToCoords(sf::Vector2i(event.mouseButton.x, event.mouseButton.y));
            std::vector<papumon> todosPapumones = papumones();

            for (size_t i = 0; i < todosPapumones.size(); ++i) {
                sf::FloatRect clickableArea(70.f, 230.f + i * 25.f, 250.f, 25.f);

                if (clickableArea.contains(mousePos)) {
                    bool alreadySelected = false;
                    for (const auto& p : currentPlayerSelectedPapumons) {
                        if (p.nombre == todosPapumones[i].nombre) {
                            alreadySelected = true;
                            break;
                        }
                    }

                    if (!alreadySelected) {
                        // Check if this Papumon has already been selected by the OTHER player
                        // This logic needs to be handled in main or by passing both teams to avoid conflicts.
                        // For now, we assume distinct selections per player.

                        currentPlayerSelectedPapumons.push_back(todosPapumones[i]);
                        if (currentPlayerSelectedPapumons.size() == 5) {
                            if (player == "JUGADOR 1") {
                                currentState = SELECTION_PLAYER2;
                            }
                            else {
                                currentState = BATTLE;
                            }
                        }
                    }
                    else {
                        std::cout << "Ya seleccionaste a ese Papumon. Elige otro.\n";
                    }
                    break; // Exit loop after handling a click
                }
            }
        }
    }
}

// SELECTION MENU (SFML) - Drawing
void drawSelectionMenu(sf::RenderWindow& window, const sf::Font& font, const std::vector<papumon>& selectedPapumons, const std::string& player) {
    sf::Text header1 = createText("################################", font, 28);
    sf::Text header2 = createText("#         " + player + "          #", font, 28); // Adjusted spacing
    sf::Text header3 = createText("#    ESCOGE A TUS PAPUMONES     #", font, 28);
    sf::Text header4 = createText("################################", font, 28);

    header1.setPosition(window.getSize().x / 2 - header1.getGlobalBounds().width / 2, 50);
    header2.setPosition(window.getSize().x / 2 - header2.getGlobalBounds().width / 2, 80);
    header3.setPosition(window.getSize().x / 2 - header3.getGlobalBounds().width / 2, 110);
    header4.setPosition(window.getSize().x / 2 - header4.getGlobalBounds().width / 2, 140);

    window.draw(header1);
    window.draw(header2);
    window.draw(header3);
    window.draw(header4);

    sf::Text availableText = createText("\nLista de Papumones disponibles:", font, 24, sf::Color::Cyan);
    availableText.setPosition(50, 200);
    window.draw(availableText);

    std::vector<papumon> todosPapumones = papumones();
    for (size_t i = 0; i < todosPapumones.size(); ++i) {
        sf::Text papumonOption = createText(std::to_string(i + 1) + ". " + todosPapumones[i].nombre + " (Tipo: " + todosPapumones[i].tipo + ")", font, 20);
        papumonOption.setPosition(70, 230 + i * 25);
        window.draw(papumonOption);
    }

    sf::Text currentSelectionText = createText("Seleccionados (" + std::to_string(selectedPapumons.size()) + "/5):", font, 22, sf::Color::Green);
    currentSelectionText.setPosition(400, 200);
    window.draw(currentSelectionText);

    for (size_t i = 0; i < selectedPapumons.size(); ++i) {
        sf::Text selectedName = createText(selectedPapumons[i].nombre, font, 20);
        selectedName.setPosition(420, 230 + i * 25);
        window.draw(selectedName);
    }
}

// BATTLE MENU (SFML) - Event Handling
void handleBattleEvents(sf::RenderWindow& window, const sf::Event& event, GameState& currentState,
    std::vector<papumon>& equipo1, std::vector<papumon>& equipo2, Turn& currentTurn,
    int& activePapumonIdx1, int& activePapumonIdx2) {
    if (event.type == sf::Event::MouseButtonReleased) {
        if (event.mouseButton.button == sf::Mouse::Left) {
            sf::Vector2f mousePos = window.mapPixelToCoords(sf::Vector2i(event.mouseButton.x, event.mouseButton.y));

            papumon* attacker = nullptr;
            papumon* defender = nullptr;

            if (currentTurn == PLAYER1_TURN) {
                if (activePapumonIdx1 >= 0 && activePapumonIdx1 < equipo1.size() && equipo1[activePapumonIdx1].vida > 0) {
                    attacker = &equipo1[activePapumonIdx1];
                    if (activePapumonIdx2 >= 0 && activePapumonIdx2 < equipo2.size()) {
                        defender = &equipo2[activePapumonIdx2];
                    }
                }
            }
            else { // PLAYER2_TURN
                if (activePapumonIdx2 >= 0 && activePapumonIdx2 < equipo2.size() && equipo2[activePapumonIdx2].vida > 0) {
                    attacker = &equipo2[activePapumonIdx2];
                    if (activePapumonIdx1 >= 0 && activePapumonIdx1 < equipo1.size()) {
                        defender = &equipo1[activePapumonIdx1];
                    }
                }
            }

            if (attacker && defender) {
                // Calculation for button positions (should match drawBattleScene for click detection)
                float actionPanelX = 50;
                float actionPanelY = window.getSize().y - 180 - 20; // Y from drawBattleScene
                float startX = actionPanelX + 20;
                float startY = actionPanelY + 50;
                float buttonWidth = (window.getSize().x - 100 - 60) / 2; // (Panel Width - padding) / 2
                float buttonHeight = 50.0f;
                float padding = 20.0f;

                // Lógica de Ataques existentes
                for (size_t i = 0; i < attacker->ataques.size(); ++i) {
                    float col = i % 2;
                    float row = i / 2;
                    sf::FloatRect attackButtonArea(startX + col * (buttonWidth + padding), startY + row * (buttonHeight + padding), buttonWidth, buttonHeight);

                    if (attackButtonArea.contains(mousePos)) {
                        if (attacker->consumirAguante(attacker->ataques[i].costo_aguante)) {
                            std::cout << attacker->nombre << " usó " << attacker->ataques[i].nombre << "!" << std::endl;
                            defender->recibirDanio(attacker->ataques[i].poder);

                            if (defender->vida <= 0) {
                                std::cout << defender->nombre << " ha sido derrotado!" << std::endl;
                                if (currentTurn == PLAYER1_TURN) { // Player 1 attacked, Player 2's Papumon defeated
                                    int nextIdx = -1;
                                    for (size_t k = activePapumonIdx2 + 1; k < equipo2.size(); ++k) {
                                        if (equipo2[k].vida > 0) {
                                            nextIdx = k;
                                            break;
                                        }
                                    }
                                    activePapumonIdx2 = nextIdx;
                                    if (activePapumonIdx2 == -1) {
                                        currentState = GAME_OVER; // Player 2 has no more Papumons
                                        std::cout << "¡JUGADOR 1 ha ganado!" << std::endl;
                                        return; // Exit to avoid changing turn
                                    }
                                }
                                else { // Player 2 attacked, Player 1's Papumon defeated
                                    int nextIdx = -1;
                                    for (size_t k = activePapumonIdx1 + 1; k < equipo1.size(); ++k) {
                                        if (equipo1[k].vida > 0) {
                                            nextIdx = k;
                                            break;
                                        }
                                    }
                                    activePapumonIdx1 = nextIdx;
                                    if (activePapumonIdx1 == -1) {
                                        currentState = GAME_OVER; // Player 1 has no more Papumons
                                        std::cout << "¡JUGADOR 2 ha ganado!" << std::endl;
                                        return; // Exit to avoid changing turn
                                    }
                                }
                            }
                            // Switch turns after a successful attack and stamina consumption
                            currentTurn = (currentTurn == PLAYER1_TURN) ? PLAYER2_TURN : PLAYER1_TURN;
                        }
                        return; // Exit loop after handling a click (either attack or not enough stamina)
                    }
                }

                // NEW: Lógica para el botón de Regenerar Aguante
                size_t nextButtonIndex = attacker->ataques.size();
                float col = nextButtonIndex % 2;
                float row = nextButtonIndex / 2;
                sf::FloatRect regenButtonArea(startX + col * (buttonWidth + padding), startY + row * (buttonHeight + padding), buttonWidth, buttonHeight);

                if (regenButtonArea.contains(mousePos)) {
                    // *** BUG FIX START ***
                    if (attacker->aguante < attacker->aguante_max) { // Only regenerate if not at max stamina
                        attacker->regenerarAguante(12); // Regenera 12 de aguante
                        currentTurn = (currentTurn == PLAYER1_TURN) ? PLAYER2_TURN : PLAYER1_TURN; // Cambiar turno
                    }
                    else {
                        std::cout << attacker->nombre << " ya tiene el aguante al máximo y no puede regenerar más." << std::endl;
                        // Do NOT change turn if stamina is already full.
                    }
                    // *** BUG FIX END ***
                    return; // Salir después de intentar regenerar
                }
            }
        }
    }
}

// BATTLE MENU (SFML) - Drawing
void drawBattleScene(sf::RenderWindow& window, const sf::Font& font, std::vector<papumon>& equipo1, std::vector<papumon>& equipo2,
    const sf::Sprite& backgroundSprite, Turn currentTurn, int activePapumonIdx1, int activePapumonIdx2) {
    window.draw(backgroundSprite);

    // Draw active Papumons
    papumon* p1Active = nullptr;
    if (activePapumonIdx1 >= 0 && activePapumonIdx1 < equipo1.size()) {
        p1Active = &equipo1[activePapumonIdx1];
        p1Active->sprite.setPosition(150, window.getSize().y / 2 - p1Active->sprite.getGlobalBounds().height / 2);
        window.draw(p1Active->sprite);
    }

    papumon* p2Active = nullptr;
    if (activePapumonIdx2 >= 0 && activePapumonIdx2 < equipo2.size()) {
        p2Active = &equipo2[activePapumonIdx2];
        // Flip sprite for opponent's Papumon and adjust position
        p2Active->sprite.setOrigin(p2Active->sprite.getLocalBounds().width / 2, p2Active->sprite.getLocalBounds().height / 2);
        p2Active->sprite.setScale(-2.0f, 2.0f); // Flip horizontally
        p2Active->sprite.setPosition(window.getSize().x - 150, window.getSize().y / 2 - p2Active->sprite.getGlobalBounds().height / 2);
        window.draw(p2Active->sprite);
    }

    // Text information for Papumons
    if (p1Active) {
        sf::Text p1Info = createText("JUGADOR 1: " + p1Active->nombre + " (HP: " + std::to_string(p1Active->vida) + ", Aguante: " + std::to_string(p1Active->aguante) + "/" + std::to_string(p1Active->aguante_max) + ")", font, 24);
        p1Info.setPosition(50, 50);
        window.draw(p1Info);
    }
    else {
        sf::Text p1Info = createText("JUGADOR 1: Sin Papumones", font, 24);
        p1Info.setPosition(50, 50);
        window.draw(p1Info);
    }

    if (p2Active) {
        sf::Text p2Info = createText("JUGADOR 2: " + p2Active->nombre + " (HP: " + std::to_string(p2Active->vida) + ", Aguante: " + std::to_string(p2Active->aguante) + "/" + std::to_string(p2Active->aguante_max) + ")", font, 24);
        p2Info.setPosition(window.getSize().x - p2Info.getGlobalBounds().width - 50, 50);
        window.draw(p2Info);
    }
    else {
        sf::Text p2Info = createText("JUGADOR 2: Sin Papumones", font, 24);
        p2Info.setPosition(window.getSize().x - p2Info.getGlobalBounds().width - 50, 50);
        window.draw(p2Info);
    }

    // Draw attack options for the current player
    sf::Text turnText = createText("Turno: ", font, 28);
    turnText.setPosition(window.getSize().x / 2 - turnText.getGlobalBounds().width / 2, 600);
    window.draw(turnText);

    papumon* currentAttacker = nullptr;
    if (currentTurn == PLAYER1_TURN && p1Active) {
        currentAttacker = p1Active;
        turnText.setString("Turno: JUGADOR 1");
    }
    else if (currentTurn == PLAYER2_TURN && p2Active) {
        currentAttacker = p2Active;
        turnText.setString("Turno: JUGADOR 2");
    }
    else {
        turnText.setString("Turno: Esperando..."); // Should not happen in normal flow
    }
    window.draw(turnText);


    if (currentAttacker) {
        // --- Panel de Acciones ---
        sf::RectangleShape actionPanel(sf::Vector2f(window.getSize().x - 100, 180)); // Ancho casi completo, altura para 2 filas de 2 botones
        actionPanel.setPosition(50, window.getSize().y - actionPanel.getGlobalBounds().height - 20); // Abajo, con margen
        actionPanel.setFillColor(sf::Color(0, 0, 0, 180)); // Fondo oscuro semitransparente
        actionPanel.setOutlineThickness(2);
        actionPanel.setOutlineColor(sf::Color(100, 100, 100));
        window.draw(actionPanel);

        sf::Text actionsHeader = createText("Acciones de " + currentAttacker->nombre + ":", font, 24, sf::Color::Yellow);
        actionsHeader.setPosition(actionPanel.getPosition().x + 20, actionPanel.getPosition().y + 10);
        window.draw(actionsHeader);

        // Grid para botones de ataque y regenerar
        float startX = actionPanel.getPosition().x + 20;
        float startY = actionPanel.getPosition().y + 50;
        float buttonWidth = (actionPanel.getSize().x - 60) / 2; // Dos columnas con 20px de espacio entre ellas
        float buttonHeight = 50.0f;
        float padding = 20.0f; // Espacio entre botones

        // Dibuja los botones de ataque
        for (size_t i = 0; i < currentAttacker->ataques.size(); ++i) {
            float col = i % 2; // 0 o 1 para columna
            float row = i / 2; // 0 o 1 para fila

            sf::RectangleShape attackButtonRect(sf::Vector2f(buttonWidth, buttonHeight));
            attackButtonRect.setPosition(startX + col * (buttonWidth + padding), startY + row * (buttonHeight + padding));
            attackButtonRect.setFillColor(sf::Color(70, 70, 70, 200));
            attackButtonRect.setOutlineThickness(2);
            attackButtonRect.setOutlineColor(sf::Color::White);
            window.draw(attackButtonRect);

            sf::Text attackText = createText(currentAttacker->ataques[i].nombre + "\n(Poder: " + std::to_string(currentAttacker->ataques[i].poder) + ", Aguante: " + std::to_string(currentAttacker->ataques[i].costo_aguante) + ")", font, 16);
            attackText.setPosition(attackButtonRect.getPosition().x + 10, attackButtonRect.getPosition().y + 5); // Pequeño margen interno
            window.draw(attackText);
        }

        // Dibuja el botón de Regenerar Aguante
        // Se coloca en la siguiente posición disponible en la cuadrícula
        size_t nextButtonIndex = currentAttacker->ataques.size();
        float col = nextButtonIndex % 2;
        float row = nextButtonIndex / 2;

        sf::RectangleShape regenButtonRect(sf::Vector2f(buttonWidth, buttonHeight));
        regenButtonRect.setPosition(startX + col * (buttonWidth + padding), startY + row * (buttonHeight + padding));
        regenButtonRect.setFillColor(sf::Color(50, 150, 50, 200)); // Un color diferente para distinguirlo
        regenButtonRect.setOutlineThickness(2);
        regenButtonRect.setOutlineColor(sf::Color::White);
        window.draw(regenButtonRect);

        sf::Text regenText = createText("Regenerar Aguante\n(+12 Aguante)", font, 16);
        regenText.setPosition(regenButtonRect.getPosition().x + 10, regenButtonRect.getPosition().y + 5);
        window.draw(regenText);
    }
}

void drawGameOver(sf::RenderWindow& window, const sf::Font& font, const std::string& winner) {
    sf::Text gameOverText = createText("¡Juego Terminado!", font, 60, sf::Color::Red);
    gameOverText.setPosition(window.getSize().x / 2 - gameOverText.getGlobalBounds().width / 2, window.getSize().y / 2 - 100);
    window.draw(gameOverText);

    sf::Text winnerText = createText("¡" + winner + " ha ganado!", font, 40, sf::Color::Green);
    winnerText.setPosition(window.getSize().x / 2 - winnerText.getGlobalBounds().width / 2, window.getSize().y / 2);
    window.draw(winnerText);

    sf::Text restartText = createText("Haz clic para volver al menú principal", font, 24, sf::Color::White);
    restartText.setPosition(window.getSize().x / 2 - restartText.getGlobalBounds().width / 2, window.getSize().y / 2 + 100);
    window.draw(restartText);
}


// =====================================================================
// FUNCIÓN PRINCIPAL (main)
// =====================================================================

int main() {
    sf::RenderWindow window(sf::VideoMode(1280, 720), "PAPUMON :D");
    window.setFramerateLimit(60);

    sf::Font font;
    if (!font.loadFromFile(ASSETS_BASE_PATH + "arial.ttf")) {
        std::cerr << "Error: No se pudo cargar la fuente arial.ttf desde la ruta: " << ASSETS_BASE_PATH << "arial.ttf" << std::endl;
        return -1;
    }

    sf::Texture backgroundTexture;
    sf::Sprite backgroundSprite;
    if (!backgroundTexture.loadFromFile(ASSETS_BASE_PATH + "backgrounds/fondo_batalla.png")) {
        std::cerr << "Error: No se pudo cargar el fondo de batalla desde la ruta: " << ASSETS_BASE_PATH << "backgrounds/fondo_batalla.png" << std::endl;
        // Consider exiting or displaying an error state if a critical asset is missing
    }
    else {
        backgroundSprite.setTexture(backgroundTexture);
        backgroundSprite.setScale(
            static_cast<float>(window.getSize().x) / backgroundTexture.getSize().x,
            static_cast<float>(window.getSize().y) / backgroundTexture.getSize().y
        );
    }

    GameState currentState = MAIN_MENU;
    Turn currentTurn = PLAYER1_TURN; // Start with Player 1's turn
    int activePapumonIdx1 = 0; // Index of the currently active Papumon for Player 1
    int activePapumonIdx2 = 0; // Index of the currently active Papumon for Player 2
    std::string winnerName = ""; // To store the winner's name for Game Over screen

    std::vector<papumon> equipo1;
    std::vector<papumon> equipo2;

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            switch (currentState) {
            case MAIN_MENU:
                handleMainMenuEvents(window, event, currentState);
                // Reset game state when returning to main menu
                if (currentState != MAIN_MENU) {
                    equipo1.clear();
                    equipo2.clear();
                    activePapumonIdx1 = 0;
                    activePapumonIdx2 = 0;
                    currentTurn = PLAYER1_TURN;
                    winnerName = "";
                }
                break;
            case SELECTION_PLAYER1:
                handleSelectionEvents(window, event, currentState, equipo1, "JUGADOR 1", font);
                break;
            case SELECTION_PLAYER2:
                handleSelectionEvents(window, event, currentState, equipo2, "JUGADOR 2", font);
                break;
            case BATTLE:
                handleBattleEvents(window, event, currentState, equipo1, equipo2, currentTurn, activePapumonIdx1, activePapumonIdx2);
                // Check if game is over after battle events
                if (currentState == GAME_OVER) {
                    if (activePapumonIdx1 == -1) winnerName = "JUGADOR 2";
                    else if (activePapumonIdx2 == -1) winnerName = "JUGADOR 1";
                }
                break;
            case GAME_OVER:
                if (event.type == sf::Event::MouseButtonReleased) {
                    currentState = MAIN_MENU; // Click to return to main menu
                }
                break;
            }
        }

        window.clear(sf::Color(50, 50, 50));

        switch (currentState) {
        case MAIN_MENU:
            drawMainMenu(window, font);
            break;
        case SELECTION_PLAYER1:
            drawSelectionMenu(window, font, equipo1, "JUGADOR 1");
            break;
        case SELECTION_PLAYER2:
            drawSelectionMenu(window, font, equipo2, "JUGADOR 2");
            break;
        case BATTLE:
            drawBattleScene(window, font, equipo1, equipo2, backgroundSprite, currentTurn, activePapumonIdx1, activePapumonIdx2);
            break;
        case GAME_OVER:
            drawGameOver(window, font, winnerName);
            break;
        }

        window.display();
    }

    return 0;
}
